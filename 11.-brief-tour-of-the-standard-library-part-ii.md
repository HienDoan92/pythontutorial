# 11. Khám phá thư viện chuẩn — phần II



Chuyến đi thứ hai này bao hàm những module nâng cao hơn sẽ hỗ trợ cho các nhu cầu lập trình chuyên nghiệp. Những module này hiếm khi xuất hiện trong các đoạn mã nhỏ.

### 11.1. Định dạng ngõ ra (Output Formatting)

Module [`reprlib`](https://docs.python.org/3/library/reprlib.html#module-reprlib) cung cấp một phiên bản tùy chỉnh của [`repr()`](https://docs.python.org/3/library/functions.html#repr) cho những hiện thị rút gọn của những containers lớn:&gt;&gt;&gt;

```text
>>> import reprlib
>>> reprlib.repr(set('supercalifragilisticexpialidocious'))
"{'a', 'c', 'd', 'e', 'f', 'g', ...}"
```

Module [`pprint`](https://docs.python.org/3/library/pprint.html#module-pprint) hỗ trợ kiểm soát tinh vi hơn qua việc xuất cả những đối tượng có sẵn và được người dùng định nghĩa. Khi kết quả dài hơn một dòng, “pretty printer” thêm vào dòng trống và căn lề để cấu trúc dữ liệu hiển thị rõ ràng hơn:&gt;&gt;&gt;

```text
>>> import pprint
>>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
...     'yellow'], 'blue']]]
...
>>> pprint.pprint(t, width=30)
[[[['black', 'cyan'],
   'white',
   ['green', 'red']],
  [['magenta', 'yellow'],
   'blue']]]
```

Module [`textwrap`](https://docs.python.org/3/library/textwrap.html#module-textwrap) định dạng đoạn văn bản cho phù hợp với chiều rộng màn hình hiển thị cho trước:&gt;&gt;&gt;

```text
>>> import textwrap
>>> doc = """The wrap() method is just like fill() except that it returns
... a list of strings instead of one big string with newlines to separate
... the wrapped lines."""
...
>>> print(textwrap.fill(doc, width=40))
The wrap() method is just like fill()
except that it returns a list of strings
instead of one big string with newlines
to separate the wrapped lines.
```

Module [`locale`](https://docs.python.org/3/library/locale.html#module-locale) truy cập vào một cơ sở dữ liệu của các định dạng dữ liệu cụ thể theo văn hóa. Thuộc tính nhóm của hàm định dạng của locale cung cấp một cách thức trực tiếp cho việc định dạng số với các phân cách nhóm:&gt;&gt;&gt;

```text
>>> import locale
>>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
'English_United States.1252'
>>> conv = locale.localeconv()          # get a mapping of conventions
>>> x = 1234567.8
>>> locale.format("%d", x, grouping=True)
'1,234,567'
>>> locale.format_string("%s%.*f", (conv['currency_symbol'],
...                      conv['frac_digits'], x), grouping=True)
'$1,234,567.80'
```

### 11.2. Khuôn mẫu (Templating)

Module [`string`](https://docs.python.org/3/library/string.html#module-string) bao gồm một lớp (class) đa năng [`Template`](https://docs.python.org/3/library/string.html#string.Template) với cú pháp được đơn giản hóa phù hợp cho việc chỉnh sửa của người dùng cuối(end-user). Việc này cho phép người dùng tùy chỉnh các ứng dụng mà không cần phải thay thế.

Định dạng sử dụng các tên giữ chỗ(placeholder) biểu thị bởi `$` với các định danh hợp lệ của Python \(chữ số và dấu gạch dưới\). Sử dụng dấu ngoặc nhọn cho placeholder cho phép nhiều kí tự chữ số theo sau nó mà không cần có dấu cách. Việc sử dụng `$$` trả về `$`, tức là bỏ qua chức năng của `$` trong cú pháp, hiểu như là một ký tự (tương tự escape `\` trong Linux shell) :&gt;&gt;&gt;

```text
>>> from string import Template
>>> t = Template('${village}folk send $$10 to $cause.')
>>> t.substitute(village='Nottingham', cause='the ditch fund')
'Nottinghamfolk send $10 to the ditch fund.'
```

Phương pháp [`substitute()`](https://docs.python.org/3/library/string.html#string.Template.substitute) tạo ra một [`KeyError`](https://docs.python.org/3/library/exceptions.html#KeyError) khi một placeholder không được hỗ trợ trong từ điển hoặc đối số từ khóa. Cho những ứng dụng kiểu như tổng hợp mail, dữ liệu được cung cấp có thể chưa hoàn chỉnh và phương pháp [`safe_substitute()`](https://docs.python.org/3/library/string.html#string.Template.safe_substitute) có thể phù hợp hơn — nó sẽ giữ nguyên placeholders nếu dữ liệu bị thiếu:&gt;&gt;&gt;

```text
>>> t = Template('Return the $item to $owner.')
>>> d = dict(item='unladen swallow')
>>> t.substitute(d)
Traceback (most recent call last):
  ...
KeyError: 'owner'
>>> t.safe_substitute(d)
'Return the unladen swallow to $owner.'
```

Các lớp phụ của Template có thể chỉ rõ dấu phân cách tùy chỉnh. Ví dụ, một tiện ích đổi tên hàng loạt cho một trình ảnh có thể chọn sử dụng dấu phần trăm (%) cho placeholder như ngày hiện tại, số thứ tự ảnh, hoặc định dạng file:&gt;&gt;&gt;

```text
>>> import time, os.path
>>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
>>> class BatchRename(Template):
...     delimiter = '%'
>>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')
Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f

>>> t = BatchRename(fmt)
>>> date = time.strftime('%d%b%y')
>>> for i, filename in enumerate(photofiles):
...     base, ext = os.path.splitext(filename)
...     newname = t.substitute(d=date, n=i, f=ext)
...     print('{0} --> {1}'.format(filename, newname))

img_1074.jpg --> Ashley_0.jpg
img_1076.jpg --> Ashley_1.jpg
img_1077.jpg --> Ashley_2.jpg
```

Ứng dụng khác cho khuôn mẫu là phân chia logic chương trình từ những chi tiết của các định dạng đa ngõ ra. Điều này khiến nó khả dụng cho các khuôn mẫu tùy chỉnh thay thế ở các files XML, báo cáo văn bản, và báo cáo web HTML.

### 11.3. Làm việc với những cách bố trí bản ghi dữ liệu nhị phân (Binary Data Record Layouts)

Module [`struct`](https://docs.python.org/3/library/struct.html#module-struct) cung cấp các hàm [`pack()`](https://docs.python.org/3/library/struct.html#struct.pack) và [`unpack()`](https://docs.python.org/3/library/struct.html#struct.unpack) cho quá trình làm việc với các định dạng bản ghi nhị phân có chiều dài thay đổi được. Ví dụ tiếp theo chỉ ra cách lặp thông qua thông tin đầu (header information) trong một file ZIP mà không sử dụng module [`zipfile`](https://docs.python.org/3/library/zipfile.html#module-zipfile) . Các mã đóng gói `"H"` và `"I"` đại diện cho 2 và 4 byte số không dấu. Kí hiệu `"<"` mô tả nó đang ở kích thước tiêu chuẩn và theo thứ tự byte là little-endian:

```text
import struct

with open('myfile.zip', 'rb') as f:
    data = f.read()

start = 0
for i in range(3):                      # chỉ đến 3 header đầu tiên của file
    start += 14
    fields = struct.unpack('<IIIHH', data[start:start+16])
    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields

    start += 16
    filename = data[start:start+filenamesize]
    start += filenamesize
    extra = data[start:start+extra_size]
    print(filename, hex(crc32), comp_size, uncomp_size)

    start += extra_size + comp_size     # bỏ qua cho đến header tiếp theo
```

### 11.4. Đa luồng (Multi-threading)

Threading is a technique for decoupling tasks which are not sequentially dependent. Threads can be used to improve the responsiveness of applications that accept user input while other tasks run in the background. A related use case is running I/O in parallel with computations in another thread.

The following code shows how the high level [`threading`](https://docs.python.org/3/library/threading.html#module-threading) module can run tasks in background while the main program continues to run:

```text
import threading, zipfile

class AsyncZip(threading.Thread):
    def __init__(self, infile, outfile):
        threading.Thread.__init__(self)
        self.infile = infile
        self.outfile = outfile

    def run(self):
        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.infile)
        f.close()
        print('Finished background zip of:', self.infile)

background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print('The main program continues to run in foreground.')

background.join()    # Wait for the background task to finish
print('Main program waited until background was done.')
```

The principal challenge of multi-threaded applications is coordinating threads that share data or other resources. To that end, the threading module provides a number of synchronization primitives including locks, events, condition variables, and semaphores.

While those tools are powerful, minor design errors can result in problems that are difficult to reproduce. So, the preferred approach to task coordination is to concentrate all access to a resource in a single thread and then use the [`queue`](https://docs.python.org/3/library/queue.html#module-queue) module to feed that thread with requests from other threads. Applications using [`Queue`](https://docs.python.org/3/library/queue.html#queue.Queue) objects for inter-thread communication and coordination are easier to design, more readable, and more reliable.

### 11.5. Logging

The [`logging`](https://docs.python.org/3/library/logging.html#module-logging) module offers a full featured and flexible logging system. At its simplest, log messages are sent to a file or to `sys.stderr`:

```text
import logging
logging.debug('Debugging information')
logging.info('Informational message')
logging.warning('Warning:config file %s not found', 'server.conf')
logging.error('Error occurred')
logging.critical('Critical error -- shutting down')
```

This produces the following output:

```text
WARNING:root:Warning:config file server.conf not found
ERROR:root:Error occurred
CRITICAL:root:Critical error -- shutting down
```

By default, informational and debugging messages are suppressed and the output is sent to standard error. Other output options include routing messages through email, datagrams, sockets, or to an HTTP Server. New filters can select different routing based on message priority: `DEBUG`, `INFO`, `WARNING`, `ERROR`, and `CRITICAL`.

The logging system can be configured directly from Python or can be loaded from a user editable configuration file for customized logging without altering the application.

### 11.6. Weak References

Python does automatic memory management \(reference counting for most objects and [garbage collection](https://docs.python.org/3/glossary.html#term-garbage-collection) to eliminate cycles\). The memory is freed shortly after the last reference to it has been eliminated.

This approach works fine for most applications but occasionally there is a need to track objects only as long as they are being used by something else. Unfortunately, just tracking them creates a reference that makes them permanent. The [`weakref`](https://docs.python.org/3/library/weakref.html#module-weakref) module provides tools for tracking objects without creating a reference. When the object is no longer needed, it is automatically removed from a weakref table and a callback is triggered for weakref objects. Typical applications include caching objects that are expensive to create:&gt;&gt;&gt;

```text
>>> import weakref, gc
>>> class A:
...     def __init__(self, value):
...         self.value = value
...     def __repr__(self):
...         return str(self.value)
...
>>> a = A(10)                   # create a reference
>>> d = weakref.WeakValueDictionary()
>>> d['primary'] = a            # does not create a reference
>>> d['primary']                # fetch the object if it is still alive
10
>>> del a                       # remove the one reference
>>> gc.collect()                # run garbage collection right away
0
>>> d['primary']                # entry was automatically removed
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    d['primary']                # entry was automatically removed
  File "C:/python36/lib/weakref.py", line 46, in __getitem__
    o = self.data[key]()
KeyError: 'primary'
```

### 11.7. Tools for Working with Lists

Many data structure needs can be met with the built-in list type. However, sometimes there is a need for alternative implementations with different performance trade-offs.

The [`array`](https://docs.python.org/3/library/array.html#module-array) module provides an [`array()`](https://docs.python.org/3/library/array.html#array.array) object that is like a list that stores only homogeneous data and stores it more compactly. The following example shows an array of numbers stored as two byte unsigned binary numbers \(typecode `"H"`\) rather than the usual 16 bytes per entry for regular lists of Python int objects:&gt;&gt;&gt;

```text
>>> from array import array
>>> a = array('H', [4000, 10, 700, 22222])
>>> sum(a)
26932
>>> a[1:3]
array('H', [10, 700])
```

The [`collections`](https://docs.python.org/3/library/collections.html#module-collections) module provides a [`deque()`](https://docs.python.org/3/library/collections.html#collections.deque) object that is like a list with faster appends and pops from the left side but slower lookups in the middle. These objects are well suited for implementing queues and breadth first tree searches:&gt;&gt;&gt;

```text
>>> from collections import deque
>>> d = deque(["task1", "task2", "task3"])
>>> d.append("task4")
>>> print("Handling", d.popleft())
Handling task1
```

```text
unsearched = deque([starting_node])
def breadth_first_search(unsearched):
    node = unsearched.popleft()
    for m in gen_moves(node):
        if is_goal(m):
            return m
        unsearched.append(m)
```

In addition to alternative list implementations, the library also offers other tools such as the [`bisect`](https://docs.python.org/3/library/bisect.html#module-bisect) module with functions for manipulating sorted lists:&gt;&gt;&gt;

```text
>>> import bisect
>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
>>> bisect.insort(scores, (300, 'ruby'))
>>> scores
[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]
```

The [`heapq`](https://docs.python.org/3/library/heapq.html#module-heapq) module provides functions for implementing heaps based on regular lists. The lowest valued entry is always kept at position zero. This is useful for applications which repeatedly access the smallest element but do not want to run a full list sort:&gt;&gt;&gt;

```text
>>> from heapq import heapify, heappop, heappush
>>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
>>> heapify(data)                      # rearrange the list into heap order
>>> heappush(data, -5)                 # add a new entry
>>> [heappop(data) for i in range(3)]  # fetch the three smallest entries
[-5, 0, 1]
```

### 11.8. Decimal Floating Point Arithmetic

The [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal) module offers a [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) datatype for decimal floating point arithmetic. Compared to the built-in [`float`](https://docs.python.org/3/library/functions.html#float) implementation of binary floating point, the class is especially helpful for

* financial applications and other uses which require exact decimal representation,
* control over precision,
* control over rounding to meet legal or regulatory requirements,
* tracking of significant decimal places, or
* applications where the user expects the results to match calculations done by hand.

For example, calculating a 5% tax on a 70 cent phone charge gives different results in decimal floating point and binary floating point. The difference becomes significant if the results are rounded to the nearest cent:&gt;&gt;&gt;

```text
>>> from decimal import *
>>> round(Decimal('0.70') * Decimal('1.05'), 2)
Decimal('0.74')
>>> round(.70 * 1.05, 2)
0.73
```

The [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) result keeps a trailing zero, automatically inferring four place significance from multiplicands with two place significance. Decimal reproduces mathematics as done by hand and avoids issues that can arise when binary floating point cannot exactly represent decimal quantities.

Exact representation enables the [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) class to perform modulo calculations and equality tests that are unsuitable for binary floating point:&gt;&gt;&gt;

```text
>>> Decimal('1.00') % Decimal('.10')
Decimal('0.00')
>>> 1.00 % 0.10
0.09999999999999995

>>> sum([Decimal('0.1')]*10) == Decimal('1.0')
True
>>> sum([0.1]*10) == 1.0
False
```

The [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal) module provides arithmetic with as much precision as needed:&gt;&gt;&gt;

```text
>>> getcontext().prec = 36
>>> Decimal(1) / Decimal(7)
Decimal('0.142857142857142857142857142857142857')
```

